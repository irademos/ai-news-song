<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Daily Spin</title>

  <style>
    /* =========================
       Design Tokens / Reset
    ========================== */
    :root{
      color-scheme: light dark;
      --bg:#0d1117;
      --surface:#161b22;
      --surface-alt:#1f2933;
      --accent:#f59e0b;
      --text:#f8fafc;
      --muted:#94a3b8;
      --mobile-nav-height:64px;
      --mobile-audio-height: 110px;
      font-family:"Inter","Segoe UI",Roboto,system-ui,-apple-system,sans-serif;
    }
    *{ box-sizing:border-box }
    h1,h2,h3,p{ margin:0 }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:stretch;
      padding:2rem;
      color:var(--text);
      background:
        radial-gradient(circle at top left, rgba(245,158,11,.08), transparent 45%),
        var(--bg);
    }

    /* =========================
       App Layout (Desktop-first)
    ========================== */
    .app-shell{
      width:min(1080px,100%);
      display:grid;
      grid-template-columns:minmax(240px,280px) minmax(320px,640px);
      gap:2rem;
      padding:2rem;
      border-radius:28px;
      background:rgba(15,23,42,.7);
      backdrop-filter:blur(24px);
      box-shadow:0 24px 60px rgba(15,23,42,.4);
      position:relative;
      z-index:40; /* keep above mobile scrim by default */
      min-height: 90vh;     /* always at least full viewport height */
      height: 90dvh;        /* modern browsers: dynamic viewport height */
      box-sizing: border-box;
    }

    .sidebar{
      display:flex;
      flex-direction:column;
      gap:2rem;
    }

    .sidebar-section{
      display:flex;
      flex-direction:column;
      gap:1rem;
      max-height:65vh;
    }
    .sidebar-section header{
      display:flex;
      flex-direction:column;
      gap:.35rem;
    }
    .sidebar-section h2{
      font-size:1.25rem;
      font-weight:600;
      letter-spacing:.01em;
    }
    .sidebar-section p{ font-size:.9rem; color:var(--muted) }

    /* Hidden on mobile; visible desktop-only */
    .desktop-sidebar-tabs { display: none; }

    @media (min-width: 861px) {
      .desktop-sidebar-tabs {
        display: inline-flex;
        gap: .5rem;
        padding: .35rem;
        background: rgba(148,163,184,.15);
        border-radius: 999px;
        align-self: flex-start;
        margin-bottom: .75rem;
      }
      .desktop-sidebar-tab {
        background: transparent;
        border: none;
        color: var(--muted);
        padding: .45rem 1rem;
        border-radius: 999px;
        font-weight: 600;
        letter-spacing: .01em;
        cursor: pointer;
        transition: background .2s ease, color .2s ease, transform .2s ease;
      }
      .desktop-sidebar-tab.active {
        background: rgba(15,23,42,.8);
        color: var(--text);
        box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      }

      /* Desktop: only show the active sidebar section */
      .sidebar .sidebar-section { display: none; }
      .sidebar .sidebar-section.active { display: flex; }

      /* Keep your existing desktop layout constraints */
      .headline-list, .song-list {
        max-height: 90vh;
      }
    }


    /* Lists */
    .headline-list,.song-list{
      list-style:none;
      margin:0; padding:0;
      display:flex; flex-direction:column; gap:.75rem;
      overflow-y:auto;
    }

    /* List Items */
    .headline-list button,
    .song-list button{
      width:100%;
      display:grid;
      gap:.35rem;
      grid-template-columns:minmax(0,1fr);
      background:transparent;
      color:inherit;
      border:1px solid rgba(148,163,184,.2);
      border-radius:14px;
      padding:.9rem 1rem;
      text-align:left;
      cursor:pointer;
      transition:transform .15s ease, border-color .2s ease, background .2s ease;
    }
    .song-list button{
      grid-template-columns:72px 1fr;
      align-items:center;
      gap:.75rem;
    }
    .headline-list button:hover,
    .song-list button:hover{
      transform:translateY(-2px);
      border-color:rgba(245,158,11,.5);
      background:rgba(15,23,42,.55);
    }
    .headline-list .back-button{
      border-color:rgba(148,163,184,.35);
      background:rgba(15,23,42,.35);
    }
    .headline-list .back-button .song-title{
      display:flex; align-items:center; gap:.5rem;
    }
    .headline-list button.active,
    .song-list button.active{
      border-color:var(--accent);
      background:rgba(245,158,11,.12);
    }
    .song-title{ font-weight:600; font-size:1rem }
    .song-meta{ font-size:.85rem; color:var(--muted); display:flex; gap:.5rem; align-items:baseline }

    /* Thumbs */
    .song-thumb{
      position:relative;
      width:72px; aspect-ratio:1/1;
      border-radius:16px; overflow:hidden;
      background:linear-gradient(135deg, rgba(245,158,11,.25), rgba(96,165,250,.25));
      display:flex; align-items:center; justify-content:center;
      color:rgba(226,232,240,.85);
      font-size:.7rem; letter-spacing:.1em; text-transform:uppercase; font-weight:600;
    }
    .song-thumb img{ display:none; width:100%; height:100%; object-fit:cover }
    .song-thumb.has-image img{ display:block }
    .song-thumb.has-image .song-thumb-placeholder{ display:none }
    .song-thumb-placeholder{ pointer-events:none }
    .song-info{ display:flex; flex-direction:column; gap:.35rem; min-width:0 }

    /* Player Panel */
    .player-panel{
      display:flex; flex-direction:column; gap:1rem;
      padding:1rem; border-radius:24px;
      background:linear-gradient(145deg, rgb(15,23,42), rgb(17,24,39));
      box-shadow:inset 0 1px 0 rgba(148,163,184,.07);
      min-height: 70vh;
      overflow: auto;
      box-sizing: border-box;
    }
    .player-header{ display:flex; flex-direction:column; gap:.6rem }
    .player-header h1{ font-size:clamp(2rem,4vw,2.8rem); font-weight:700; letter-spacing:-.02em }
    .player-header p{ color:var(--muted); font-size:1rem; line-height:1.6 }
    .player-header .tag{
      display:inline-flex; align-items:center; gap:.5rem;
      padding:.35rem .85rem; border-radius:999px;
      background:rgba(245,158,11,.18); color:var(--accent);
      font-size:.85rem; font-weight:600; text-transform:uppercase; letter-spacing:.08em;
    }

    audio{
      width:100%; height:54px; border-radius:12px;
      background:rgba(15,23,42,.6);
    }

    /* Tabs */
    .player-tabs{
      display:inline-flex; gap:.25rem; padding:.35rem;
      background:rgba(148,163,184,.15); border-radius:999px; align-self:flex-start;
    }
    .player-tab{
      background:transparent; border:none; cursor:pointer;
      color:var(--muted); font-weight:600; letter-spacing:.01em;
      padding:.4rem .95rem; border-radius:999px;
      transition:background .2s ease, color .2s ease;
    }
    .player-tab.active{
      background:rgba(15,23,42,.8); color:var(--text);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.05);
    }

    .tab-panels{
      display:flex; flex-direction:column; gap:.75rem;
      flex: 1 1 auto;        /* take remaining vertical space */
      min-height: 20vh;         /* allow scrolling child to shrink */
      overflow: auto;        /* scroll THIS area first */
      padding:1.25rem 1.5rem;
      border-radius:18px;
      background:rgba(15,23,42,.55);
    }

    .tab-panel{
      flex: 1 1 auto;
      min-height: 20vh;
      overflow: auto;
      padding-right: .75rem;

      font-size: clamp(1.05rem, 1.6vw, 1.3rem);
      line-height: 1.6;
      color: rgba(226,232,240,.92);
      white-space: pre-wrap;
    }
    .tab-panel[hidden]{ display:none }

    /* Empty / Actions */
    .empty-state{ color:var(--muted); text-align:center; padding:2rem }
    .generate-song{
      margin-top:auto; padding-top:1.25rem; display:flex; flex-direction:column; gap:.75rem;
      border-top:1px solid rgba(148,163,184,.15);
    }
    .generate-controls{
      display:flex;
      flex-wrap:wrap;
      gap:.75rem;
      align-items:flex-end;
    }
    .generate-field{
      display:flex;
      flex-direction:column;
      gap:.35rem;
      flex:1 1 180px;
      min-width:150px;
      font-size:.85rem;
      color:var(--muted);
    }
    .generate-field select,
    .generate-field input{
      background:rgba(15,23,42,.85);
      border:1px solid rgba(148,163,184,.3);
      color:var(--text);
      border-radius:12px;
      padding:.6rem .75rem;
      font-size:.95rem;
      width:100%;
      transition:border-color .2s ease, box-shadow .2s ease;
    }
    .generate-field select:focus,
    .generate-field input:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(245,158,11,.25);
      outline:none;
    }
    .generate-song-status{ font-size:.9rem; color:var(--muted); min-height:1.4em }
    .generate-controls>button{
      align-self:flex-end;
    }
    .generate-song button{
      cursor:pointer;
      background:var(--accent); color:#0b0f16; border:none;
      padding:.75rem 1.5rem; border-radius:999px; font-weight:600; letter-spacing:.02em;
      transition:transform .15s ease, box-shadow .2s ease;
    }
    .generate-song button:hover:not(:disabled){ transform:translateY(-1px); box-shadow:0 10px 30px rgba(245,158,11,.35) }
    .generate-song button:disabled{ opacity:.6; cursor:not-allowed; box-shadow:none }

    .generate-song.podcast {
      border-top: 1px solid rgba(148,163,184,.2);
      padding-top: 1.5rem;
      margin-top: .5rem;
    }

    .podcast-output {
      display: flex;
      flex-direction: column;
      gap: .75rem;
      padding: 1rem;
      border-radius: 16px;
      background: rgba(15,23,42,.45);
      border: 1px solid rgba(148,163,184,.15);
    }

    .podcast-script {
      color: rgba(226,232,240,.92);
      white-space: pre-wrap;
      line-height: 1.6;
    }

    .podcast-list {
      list-style: decimal;
      padding-left: 1.25rem;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: .75rem;
      color: rgba(226,232,240,.92);
    }

    .podcast-list li {
      padding: .75rem .85rem;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.15);
      background: rgba(15,23,42,.35);
      line-height: 1.55;
    }

    .podcast-list li.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(245,158,11,.35);
    }

    /* Desktop/tablet: show in right column under the player panel */
    @media (min-width: 861px){
      #dockedAudio {
        position: static;          /* not fixed on desktop */
        grid-column: 2;            /* under the player (right column) */
        align-self: end;
        width: 100%;
        display: block;
      }
      #dockedAudio audio {
        width: 100%;
        height: 54px;
        border-radius: 12px;
        background: rgba(15,23,42,.6);
        display: block;
      }
    }

    #dockedAudio{
      display:flex;
      flex-direction:column;
      gap:.35rem;
    }
    .podcast-controls{
      display:flex;
      align-items:center;
      gap:.5rem;
    }
    .podcast-controls button{
      flex:0 0 auto;
      border:1px solid rgba(148,163,184,.25);
      background:rgba(15,23,42,.65);
      color:var(--text);
      border-radius:12px;
      padding:.55rem .85rem;
      font-weight:600;
      letter-spacing:.01em;
      cursor:pointer;
      transition:background .2s ease, border-color .2s ease, transform .15s ease;
    }
    .podcast-controls button:hover:not(:disabled){
      background:rgba(245,158,11,.16);
      border-color:rgba(245,158,11,.5);
      transform:translateY(-1px);
    }
    .podcast-controls button:disabled{
      opacity:.6;
      cursor:not-allowed;
    }
    .podcast-controls__spacer{ flex:1 1 auto; }


    #songTitle {
      font-size: clamp(1.9rem, 5vw, 1.5rem);  /* smaller, responsive */
      line-height: 1.3;
    }

    #songArticle {
      font-size: clamp(1.0rem, 5vw, 1.2rem);  /* smaller, responsive */
      line-height: 1.3;
    }

    #songLyrics {
      font-size: clamp(1.0rem, 5vw, 1.2rem);  /* smaller, responsive */
      line-height: 1.3;
    }

    /* Hide mobile nav on desktop */
    .mobile-bottom-nav {
      display: none;
    }

    /* Only show on mobile */
    @media (max-width: 860px) {
      .mobile-bottom-nav {
        display: flex;
      }
    }

    /* Hide when no audio */
    /* body:not(.has-audio) #dockedAudio { display: none; } */

    /* ===== Mobile (≤ 860px) ===== */
    @media (max-width: 860px){
      body{ padding:0; align-items:stretch; justify-content:flex-start }

      html, body {
        height: 100%;
        overflow-x: hidden;
      }
      body {
        min-height: 100dvh;           /* use dynamic viewport */
      }
      
      .app-shell{
        width:100%;
        min-height:100vh;
        border-radius:0;
        grid-template-columns:1fr;
        gap:1.5rem;
        /* only bottom nav now */
        padding: 1.25rem 1.25rem calc(var(--mobile-nav-height) + var(--mobile-audio-height) + 3rem);
        padding-bottom: calc(var(--mobile-nav-height) + max(0.75rem, env(safe-area-inset-bottom)) + 2rem);
      }

      /* dock the audio player */
      #dockedAudio{
        position: fixed;
        left: max(1rem, env(safe-area-inset-left));
        right: max(1rem, env(safe-area-inset-right));
        bottom: calc(var(--mobile-nav-height) + max(0.75rem, env(safe-area-inset-bottom)) + 0.5rem);
        min-height: var(--mobile-audio-height);
        z-index: 60; /* above nav (which is 50) */
        border-radius: 14px;
        background: rgba(15,23,42,.95);
        border: 1px solid rgba(148,163,184,.15);
        box-shadow: 0 -12px 28px rgba(15,23,42,.35);
        padding: .6rem;
      }
      #dockedAudio audio{
        width:100%;
        height:56px;
        display:block;
        border-radius:12px;
        background:rgba(15,23,42,.6);
      }

      #songTitle {
        font-size: clamp(1.2rem, 5vw, 1.5rem);  /* smaller, responsive */
        line-height: 1.3;
      }

      /* when no audio, hide dock + shrink padding */
      /* body:not(.has-audio) #dockedAudio{ display:none; } */
      /* body:not(.has-audio) .app-shell{
        padding-bottom: calc(var(--mobile-nav-height) + 2.5rem);
      } */

      /* “pages”: headlines, recent, player */
      .sidebar-section,
      .player-panel{
        padding-bottom:1rem;
        min-height: 85vh;
      }

      /* hide when not active */
      .sidebar-section:not(.active),
      .player-panel:not(.active){
        display:none;
      }

      /* show when active */
      .sidebar-section.active,
      .player-panel.active{
        display:flex;
      }

      /* keep previous list/thumb tweaks */
      .headline-list,.song-list{ max-height:none }
      .song-list button{ grid-template-columns:64px 1fr }
      .song-thumb{ width:64px }

      /* bottom nav (same look, now standalone) */
      .mobile-bottom-nav{
        position:fixed; left:0; right:0; bottom:0;
        height:var(--mobile-nav-height);
        display:flex; align-items:center; justify-content:center; gap:.75rem;
        padding:.75rem max(1rem, env(safe-area-inset-left)) max(.75rem, env(safe-area-inset-bottom)) max(1rem, env(safe-area-inset-right));
        border-radius:18px 18px 0 0;
        background:rgba(15,23,42,.92);
        border-top:1px solid rgba(148,163,184,.15);
        box-shadow:0 -18px 38px rgba(15,23,42,.35);
        z-index:50;
      }
      .mobile-bottom-nav__button{
        flex:1; background:rgba(148,163,184,.12); border:none; color:var(--muted);
        padding:.75rem 1rem; border-radius:14px; font-weight:600; letter-spacing:.01em; cursor:pointer;
        transition:background .2s ease, color .2s ease, transform .2s ease;
      }
      .mobile-bottom-nav__button.active{
        background:rgba(245,158,11,.18); color:var(--accent);
        transform:translateY(-2px);
      }
    }
  </style>
</head>

<body>
  <div class="app-shell">
    <!-- Sidebar -->
    <aside class="sidebar">
      <nav class="desktop-sidebar-tabs" role="tablist" aria-label="Sidebar sections (desktop)">
        <button
          type="button"
          class="desktop-sidebar-tab active"
          data-role="desktop-sidebar-tab"
          data-target="headlines"
          role="tab"
          aria-selected="true"
        >
          Headlines
        </button>
        <button
          type="button"
          class="desktop-sidebar-tab"
          data-role="desktop-sidebar-tab"
          data-target="recent"
          role="tab"
          aria-selected="false"
        >
          Recent Spins
        </button>
      </nav>

      <section class="sidebar-section" data-section="headlines">
        <header>
          <h2>Top Headlines</h2>
          <p>Select a headline to read the story and optionally spin a new track.</p>
        </header>
        <ul id="headlineList" class="headline-list"></ul>
      </section>

      <section class="sidebar-section" data-section="recent">
        <header>
          <h2>Recent Spins</h2>
          <p>The latest Suno creations saved from Daily Spin.</p>
        </header>
        <ul id="songList" class="song-list"></ul>
      </section>
    </aside>

    <!-- Player -->
    <main class="player-panel" data-section="player" aria-hidden="false">
      <div class="player-header">
        <span id="songTag" class="tag">Top Stories</span>
        <h1 id="songTitle">Choose a headline</h1>
        <p id="songMeta">Select a headline from the list to load the article.</p>
      </div>

      <div class="player-tabs" role="tablist" aria-label="Now playing content">
        <button type="button" id="articleTab" class="player-tab active" data-role="player-tab" data-tab="article" role="tab" aria-controls="songArticle" aria-selected="true">Article</button>
        <button type="button" id="lyricsTab" class="player-tab" data-role="player-tab" data-tab="lyrics" role="tab" aria-controls="songLyrics" aria-selected="false">Lyrics</button>
      </div>

      <div class="tab-panels">
        <section id="songArticle" class="tab-panel" data-role="tab-panel" data-tab="article" role="tabpanel" aria-labelledby="articleTab">
          Article summaries will appear here after you pick a headline.
        </section>
        <section id="songLyrics" class="tab-panel" data-role="tab-panel" data-tab="lyrics" role="tabpanel" aria-labelledby="lyricsTab" hidden>
          Lyrics will appear here after you generate or load a spin.
        </section>
      </div>

      <section class="generate-song">
        <div class="generate-controls">
          <label class="generate-field" for="genreSelect">
            <span>Genre</span>
            <select id="genreSelect" name="genreSelect">
              <option value="">Select a genre (optional)</option>
              <option value="pop">Pop</option>
              <option value="rock">Rock</option>
              <option value="hip-hop">Hip-Hop</option>
              <option value="electronic">Electronic</option>
              <option value="jazz">Jazz</option>
              <option value="acoustic">Acoustic</option>
              <option value="ambient">Ambient</option>
            </select>
          </label>
          <label class="generate-field" for="customTagsInput">
            <span>Custom tags</span>
            <input id="customTagsInput" name="customTagsInput" type="text" placeholder="Comma-separated tags" autocomplete="off" />
          </label>
          <button type="button" id="generateSongButton" disabled>Generate Song</button>
        </div>
        <p id="generateSongStatus" class="generate-song-status" aria-live="polite"></p>
      </section>

      <section class="generate-song podcast">
        <div class="generate-controls">
          <div class="generate-field">
            <span>Podcast episode</span>
            <p class="generate-song-status">Create a spoken recap plus three AI tracks from today’s headlines.</p>
          </div>
          <button type="button" id="generatePodcastButton">Generate Podcast</button>
        </div>
        <div class="podcast-output" id="podcastOutput">
          <p id="podcastStatus" class="generate-song-status">Press Generate Podcast to start an AI-hosted news rundown.</p>
          <div class="podcast-script" id="podcastOverview" aria-live="polite"></div>
          <ol id="podcastSegments" class="podcast-list"></ol>
        </div>
      </section>
    </main>
    
  </div>

  <div id="dockedAudio">
    <div class="podcast-controls" aria-label="Podcast playback controls">
      <button type="button" id="podcastPrevButton" aria-label="Previous podcast section" disabled>Prev</button>
      <button type="button" id="podcastPlayPauseButton" aria-label="Pause or resume podcast narration" disabled>Pause</button>
      <div class="podcast-controls__spacer" aria-hidden="true"></div>
      <button type="button" id="podcastNextButton" aria-label="Next podcast section" disabled>Next</button>
    </div>
    <audio id="audioPlayer" controls preload="none">
      <source id="audioSource" src="" type="audio/mpeg" />
      Your browser does not support the audio element.
    </audio>
  </div>
  

  <!-- Mobile Bottom Bar -->
  <nav class="mobile-bottom-nav" aria-label="Primary">
    <button type="button" class="mobile-bottom-nav__button active" data-role="mobile-nav" data-target="headlines">
      Headlines
    </button>
    <button type="button" class="mobile-bottom-nav__button" data-role="mobile-nav" data-target="recent">
      Recent Spins
    </button>
    <button type="button" class="mobile-bottom-nav__button" data-role="mobile-nav" data-target="player">
      Now Playing
    </button>
  </nav>

  <!-- Templates -->
  <template id="headlineItemTemplate">
    <li>
      <button type="button" data-role="headline-item">
        <span class="song-title"></span>
        <span class="song-meta"></span>
      </button>
    </li>
  </template>

  <template id="headlineSourceTemplate">
    <li>
      <button type="button" data-role="headline-source">
        <span class="song-title"></span>
        <span class="song-meta"></span>
      </button>
    </li>
  </template>

  <template id="songItemTemplate">
    <li>
      <button type="button" data-role="song-item">
        <div class="song-thumb" aria-hidden="true">
          <img loading="lazy" decoding="async" alt=""/>
          <span class="song-thumb-placeholder">AI</span>
        </div>
        <div class="song-info">
          <span class="song-title"></span>
          <span class="song-meta"></span>
        </div>
      </button>
    </li>
  </template>

  <!-- =========================
       Script (Organized)
  ========================== -->
  <script src="https://js.puter.com/v2/"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import {
      getFirestore, collection, query, orderBy, limit, onSnapshot, addDoc, updateDoc, serverTimestamp
    } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

    /* ---------- Utilities ---------- */
    const PROXYABLE_AUDIO_HOSTS = ['audiopipe.suno.ai','cdn.suno.ai','cdn1.suno.ai','cdn2.suno.ai','cdn3.suno.ai'];
    const SUNO_AUDIO_HOST_MIGRATIONS = new Map([['audiopipe.suno.ai','cdn1.suno.ai']]);
    const AUDIOPIPE_HOST_HINT = 'audiopipe';

    const isFinalSunoState = s => typeof s==='string' && ['complete','completed','succeeded'].includes(s.trim().toLowerCase());
    const sanitizeImageUrl = v => {
      if (typeof v!=='string') return '';
      const t = v.trim(); if (!t) return ''; if (t.startsWith('/') || t.startsWith('data:image/')) return t;
      try { const u=new URL(t); return ['http:','https:'].includes(u.protocol)?u.toString():'' } catch { return '' }
    };
    const normalizeSunoAudioUrl = (v,{migrateHost=false}={})=>{
      if (typeof v!=='string') return '';
      const t=v.trim(); if(!t) return ''; if(t.startsWith('/')) return t;
      try{ const u=new URL(t); const h=u.hostname.toLowerCase();
        if(migrateHost&&SUNO_AUDIO_HOST_MIGRATIONS.has(h)) u.hostname=SUNO_AUDIO_HOST_MIGRATIONS.get(h);
        return u.toString();
      }catch{ return t }
    };
    const sanitizeAudioUrl = (v,opts)=>normalizeSunoAudioUrl(v,opts);
    const hasAudioPipeHost = url => typeof url==='string' && url.toLowerCase().includes(AUDIOPIPE_HOST_HINT);
    const needsAudioProxy = url => { try{ const h=new URL(url).hostname.toLowerCase(); return PROXYABLE_AUDIO_HOSTS.some(a=>h===a||h.endsWith('.'+a)) }catch{ return false } };
    const getPlayableAudioUrl = raw => {
      const s = sanitizeAudioUrl(raw); if(!s) return '';
      if (s.startsWith('/api/proxy-audio?')) return s;
      return needsAudioProxy(s) ? `/api/proxy-audio?src=${encodeURIComponent(s)}` : s;
    };
    const formatDate = d => d instanceof Date && !Number.isNaN(d) ? d.toLocaleDateString(undefined,{weekday:'short',month:'short',day:'numeric'}) : '';
    const formatTime = d => d instanceof Date && !Number.isNaN(d) ? d.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'}) : '';
    const formatDateTime = d => { const a=formatDate(d), b=formatTime(d); return a&&b?`${a} • ${b}`:a||b||'Generated' };
    const coerceDate = (ts, iso)=>{
      if(ts && typeof ts.toDate==='function'){ try{ return ts.toDate() }catch{}}
      if(typeof iso==='string'){ const d=new Date(iso); if(!Number.isNaN(d)) return d; }
      return null;
    };

    /* ---------- State ---------- */
    let db=null, firebaseInitPromise=null;
    let songsCache=[], spinsCache=[], podcastsCache=[], currentSongId=null, unsubscribeSongs=null, unsubscribePodcasts=null;
    let headlinesCache=[], groupedHeadlines=new Map(), headlineViewMode='sources', selectedHeadlineSource=null;
    let currentHeadlineKey=null, selectedStory=null, latestArticleContent='', latestSummary='', isGenerating=false;
    let podcastState=null, podcastIsRunning=false, podcastQueueIndex=-1, podcastNavRequest=null, currentPodcastStep=-1;
    let generateSongButton=null, generatePodcastButton=null, genreSelect=null, customTagsInput=null, activeContentTab='article';
    let podcastPrevButton=null, podcastNextButton=null, podcastPlayPauseButton=null;
    let currentNarrationResolver=null, currentClipResolver=null;

    /* ---------- DOM Helpers ---------- */
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);

    const audio = document.getElementById('audioPlayer');
    if (audio){
      ['loadeddata','emptied','abort','error'].forEach(evt=>{
        audio.addEventListener(evt, updateDockState);
      });
      ['play','pause','ended'].forEach(evt=>{
        audio.addEventListener(evt, updatePodcastControlButtons);
      });
    }

    const showListEmptyState = (listId, msg)=>{
      const list = document.getElementById(listId); if(!list) return;
      list.innerHTML = `<li class="empty-state">${msg}</li>`;
    };
    const updateStatus = msg => { const el=$('#generateSongStatus'); if(el) el.textContent = msg||'' };
    const updateGenerateButton = ({disabled,text}={})=>{
      if(!generateSongButton) return;
      if(typeof disabled==='boolean') generateSongButton.disabled = disabled;
      if(typeof text==='string') generateSongButton.textContent = text;
    };
    const updatePodcastStatus = (msg)=>{
      const el=$('#podcastStatus'); if(el) el.textContent = msg || '';
    };
    const getRequestedTags = ()=>{
      const values=[];
      const genreValue = genreSelect && typeof genreSelect.value==='string' ? genreSelect.value.trim() : '';
      if(genreValue) values.push(genreValue);
      const customValueRaw = customTagsInput && typeof customTagsInput.value==='string' ? customTagsInput.value : '';
      if(customValueRaw){
        const cleaned = customValueRaw
          .split(',')
          .map(part=>part.trim())
          .filter(Boolean)
          .join(', ');
        if(cleaned) values.push(cleaned);
      }
      return values.join(', ').trim();
    };

    function setActiveDesktopSidebar(section) {
      const normalized = section === 'recent' ? 'recent' : 'headlines';

      // Update tab button states
      document.querySelectorAll('[data-role="desktop-sidebar-tab"]').forEach(btn => {
        const on = btn.dataset.target === normalized;
        btn.classList.toggle('active', on);
        btn.setAttribute('aria-selected', on ? 'true' : 'false');
      });

      // Show only the matching section in the sidebar
      document.querySelectorAll('.sidebar .sidebar-section').forEach(panel => {
        panel.classList.toggle('active', panel.dataset.section === normalized);
      });
    }


    /* ---------- Tabs / Mobile UI ---------- */
    function setActiveTab(tab){
      const t = tab==='lyrics' ? 'lyrics' : 'article';
      activeContentTab = t;
      $$('[data-role="player-tab"]').forEach(btn=>{
        const on = btn.dataset.tab===t;
        btn.classList.toggle('active',on);
        btn.setAttribute('aria-selected', on?'true':'false');
        btn.setAttribute('tabindex', on?'0':'-1');
      });
      $$('[data-role="tab-panel"]').forEach(p=>{
        p.toggleAttribute('hidden', p.dataset.tab!==t);
      });
    }

    function setActiveMobileSection(section){
      const normalized = (section==='recent' ? 'recent' : (section==='player' ? 'player' : 'headlines'));

      // nav state
      document.querySelectorAll('[data-role="mobile-nav"]').forEach(button=>{
        const on = button.dataset.target === normalized;
        button.classList.toggle('active', on);
        button.setAttribute('aria-pressed', on ? 'true' : 'false');
      });

      // “pages”: headlines/recent (sidebar sections) + player-panel
      document.querySelectorAll('.sidebar-section').forEach(panel=>{
        panel.classList.toggle('active', panel.dataset.section === normalized);
      });
      const player = document.querySelector('.player-panel');
      if (player) player.classList.toggle('active', normalized === 'player');
    }

    function updateDockState(){
      const src = document.getElementById('audioSource')?.getAttribute('src') || '';
      document.body.classList.toggle('has-audio', !!src);
    }

    const getPodcastStepCount = ()=>{
      if(!podcastState) return 0;
      const selectionsCount = Array.isArray(podcastState.selections) ? podcastState.selections.length : 0;
      return (podcastState.overviewScript ? 1 : 0) + selectionsCount;
    };

    const takePodcastNavRequest = ()=>{
      const dir = podcastNavRequest;
      podcastNavRequest = null;
      return dir;
    };

    function updatePodcastControlButtons(){
      const total = getPodcastStepCount();
      const hasPodcast = total > 0;
      const player = document.getElementById('audioPlayer');
      const isPaused = player ? player.paused : true;

      if(podcastPlayPauseButton){
        podcastPlayPauseButton.disabled = !hasPodcast;
        podcastPlayPauseButton.textContent = isPaused ? 'Play' : 'Pause';
      }

      const atFirst = currentPodcastStep <= 0;
      const atLast = currentPodcastStep >= total - 1;

      if(podcastPrevButton) podcastPrevButton.disabled = !hasPodcast || !podcastIsRunning || atFirst;
      if(podcastNextButton) podcastNextButton.disabled = !hasPodcast || !podcastIsRunning || atLast;
    }

    function requestPodcastNavigation(direction){
      if(!podcastIsRunning || !podcastState) return;
      podcastNavRequest = direction;

      if(currentNarrationResolver){
        currentNarrationResolver({nav: direction});
        currentNarrationResolver = null;
      }

      if(currentClipResolver){
        currentClipResolver();
        currentClipResolver = null;
      }

      try { currentAudio?.pause(); } catch {}
      const player = document.getElementById('audioPlayer');
      player?.pause?.();

      updatePodcastControlButtons();
    }

    function togglePodcastPause(){
      const player = document.getElementById('audioPlayer');
      if(!player) return;
      if(player.paused){ player.play().catch(()=>{}); }
      else { player.pause(); }
      updatePodcastControlButtons();
    }

    /* ---------- Podcast helpers ---------- */
    let currentAudio = null;

    async function speakText(text) {
      return new Promise(async (resolve) => {
        if (!text) { resolve({}); return; }

        // Stop any existing playback
        if (currentAudio) {
          try { currentAudio.pause(); } catch {}
          currentAudio = null;
        }

        const audioEl = document.getElementById('audioPlayer');
        const audioSource = document.getElementById('audioSource');

        let finished = false;
        const settle = (payload={}) => {
          if (finished) return;
          finished = true;
          currentNarrationResolver = null;
          currentAudio = null;
          resolve(payload);
        };

        try {
          // Create TTS audio using OpenAI alloy voice via Puter
          const audio = await puter.ai.txt2speech(text, {
            provider: "openai",
            model: "gpt-4o-mini-tts",
            voice: "alloy",
            response_format: "mp3",
            instructions: "Sound clear and friendly.",
          });

          const src = audio?.src || '';
          const useDockedPlayer = !!(audioEl && src);

          if (useDockedPlayer) {
            const onEnd = () => settle({});
            const onError = () => settle({});

            if (audioSource) {
              audioSource.src = src;
            } else if (audioEl) {
              audioEl.src = src;
            }

            audioEl?.load();
            currentAudio = audioEl;

            audioEl?.addEventListener('ended', onEnd);
            audioEl?.addEventListener('error', onError);

            const cleanup = () => {
              audioEl?.removeEventListener('ended', onEnd);
              audioEl?.removeEventListener('error', onError);
            };

            currentNarrationResolver = (payload={}) => {
              cleanup();
              try { audioEl?.pause(); } catch {}
              settle(payload);
            };

            audioEl?.play()?.catch(()=> settle({}));
            updateDockState();
          } else {
            currentAudio = audio;

            audio.onended = () => settle({});
            audio.onerror = () => settle({});

            currentNarrationResolver = (payload={}) => {
              audio.onended = null;
              audio.onerror = null;
              try { audio.pause(); } catch {}
              settle(payload);
            };

            audio.play();
          }
        } catch (err) {
          console.error("Puter/OpenAI TTS error:", err);
          settle({});
        }
      });
    }

    function renderPodcastScripts(){
      const overviewEl=$('#podcastOverview');
      const list=$('#podcastSegments');
      if(!overviewEl||!list) return;
      if(!podcastState){
        overviewEl.textContent='';
        list.innerHTML='';
        return;
      }
      overviewEl.textContent = podcastState.overviewScript || '';
      list.innerHTML='';
      (podcastState.selections||[]).forEach((seg,idx)=>{
        const li=document.createElement('li');
        li.classList.toggle('active', idx===podcastQueueIndex);
        const title=document.createElement('div');
        title.innerHTML = `<strong>${seg.headline||'Article'}</strong>${seg.source?` — ${seg.source}`:''}`;
        const script=document.createElement('div');
        script.className='podcast-script';
        script.textContent = seg.deepDiveScript || seg.overviewScript || '';
        li.appendChild(title);
        li.appendChild(script);
        list.appendChild(li);
      });
    }

    function playClip(url){
      return new Promise(resolve=>{
        const src = getPlayableAudioUrl(url);
        if(!src){ resolve(); return; }
        $('#audioSource').src = src;
        $('#audioPlayer').load();

        let finished=false;
        const finish=()=>{
          if(finished) return;
          finished=true;
          audio?.removeEventListener('ended', finish);
          audio?.removeEventListener('error', finish);
          currentClipResolver = null;
          resolve();
        };

        currentClipResolver = finish;

        audio?.addEventListener('ended', finish);
        audio?.addEventListener('error', finish);
        audio?.play().catch(()=>finish());
        updateDockState();
      });
    }

    /* ---------- Headlines UI ---------- */
    const groupHeadlinesBySource = stories=>{
      const m=new Map();
      stories.forEach(s=>{
        const src=(s.source||'Latest Headlines').trim();
        if(!m.has(src)) m.set(src,[]);
        m.get(src).push(s);
      });
      return m;
    };

    function renderHeadlineSources(){
      const list=$('#headlineList'), tpl=$('#headlineSourceTemplate'); if(!list||!tpl) return;
      const entries = Array.from(groupedHeadlines.entries()).filter(([,v])=>v.length);
      if(!entries.length){ showListEmptyState('headlineList','No fresh headlines were found. Try again later.'); return }
      list.innerHTML='';
      entries.forEach(([source,stories])=>{
        const node = tpl.content.cloneNode(true);
        const btn = node.querySelector('button');
        node.querySelector('.song-title').textContent = source;
        node.querySelector('.song-meta').textContent = `${stories.length} headline${stories.length===1?'':'s'}`;
        btn.classList.toggle('active', source===selectedHeadlineSource);
        btn.addEventListener('click', ()=> showHeadlinesForSource(source));
        list.appendChild(node);
      });
    }

    function renderHeadlineStories(stories){
      const list=$('#headlineList'), tpl=$('#headlineItemTemplate'); if(!list||!tpl) return;
      list.innerHTML='';

      // Back row
      const backItem=document.createElement('li');
      const backBtn=document.createElement('button');
      backBtn.type='button'; backBtn.dataset.role='headline-back'; backBtn.classList.add('back-button');
      backBtn.innerHTML='<span class="song-title">← Back to sources</span><span class="song-meta">Choose another news outlet</span>';
      backBtn.setAttribute('aria-label','Back to news sources');
      backBtn.addEventListener('click', showHeadlineSources);
      backItem.appendChild(backBtn); list.appendChild(backItem);

      if(!stories.length){
        const empty=document.createElement('li'); empty.className='empty-state';
        empty.textContent='No fresh headlines were found for this source.'; list.appendChild(empty); return;
      }

      stories.forEach(story=>{
        const node=tpl.content.cloneNode(true);
        const btn=node.querySelector('button');
        const title=node.querySelector('.song-title');
        const meta=node.querySelector('.song-meta');

        const key = story.link || `${story.source || 'source'}:${story.headline}`;
        const preview=(story.summary||'').trim();
        const truncated = preview.length>140 ? `${preview.slice(0,140).trimEnd()}…` : preview;

        title.textContent = story.headline || 'Untitled story';
        meta.textContent = [story.source, truncated].filter(Boolean).join(' • ');
        btn.dataset.id = key;
        btn.classList.toggle('active', key===currentHeadlineKey);
        btn.addEventListener('click', ()=> handleHeadlineSelection({ ...story, key }));
        list.appendChild(node);
      });
    }

    function refreshHeadlineView(){
      if (headlineViewMode==='sources') return renderHeadlineSources();
      if (selectedHeadlineSource){
        renderHeadlineStories(groupedHeadlines.get(selectedHeadlineSource) || []);
      }
    }
    function showHeadlineSources(){
      headlineViewMode='sources'; updateStatus('Select a news source to browse its latest headlines.'); refreshHeadlineView();
    }
    function showHeadlinesForSource(source){
      selectedHeadlineSource=source; headlineViewMode='stories';
      updateStatus('Pick a headline to read the story and optionally generate a Suno track.');
      refreshHeadlineView();
    }
    function setHeadlines(stories){
      headlinesCache=stories;
      groupedHeadlines=groupHeadlinesBySource(stories);
      selectedHeadlineSource=null; currentHeadlineKey=null; selectedStory=null;
      resetNowPlaying(); showHeadlineSources();
    }

    /* ---------- Player / Song Flow ---------- */
    function resetNowPlaying(){
      $('#songTitle').textContent='Choose a headline';
      $('#songMeta').textContent='Select a news headline to read the story and optionally spin a Suno track.';
      $('#songArticle').textContent='Article summaries will appear here after you pick a headline.';
      $('#songLyrics').textContent='Lyrics will appear here after you generate or load a spin.';
      $('#audioSource').src=''; $('#audioPlayer').load();

      const tag=$('#songTag');
      tag.textContent='Top Stories'; tag.style.background='rgba(96,165,250,.18)'; tag.style.color='#60a5fa';

      selectedStory=null; latestArticleContent=''; latestSummary='';
      setActiveTab('article'); updateGenerateButton({disabled:true, text:'Generate Song'});

      updateDockState();
      currentPodcastStep = -1;
      podcastNavRequest = null;
      updatePodcastControlButtons();
    }

    async function fetchAndDisplayArticle(story){
      if(!story?.link){ updateStatus('The selected headline does not have a readable article link.'); updateGenerateButton({disabled:true,text:'Generate Song'}); return }
      try{
        const r=await fetch('/api/article-content',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({url:story.link})});
        const body=await r.json().catch(()=>({}));
        if(!r.ok){ throw new Error(body?.error || 'Unable to load the full article right now.') }

        latestArticleContent=(body.content||'').trim();
        if(!selectedStory || selectedStory.key!==story.key) return;

        const summary=(story.summary||'').trim();
        const combined = summary && latestArticleContent ? `${summary}\n\n${latestArticleContent}` : summary || latestArticleContent;
        $('#songArticle').textContent = combined || 'The article is available, but it is empty.';

        const tag=$('#songTag'); tag.textContent='Article Ready'; tag.style.background='rgba(52,211,153,.2)'; tag.style.color='#34d399';
        updateStatus('Article loaded. Ready to generate a Suno song.');
        updateGenerateButton({disabled:false, text:'Generate Song'});
      }catch(err){
        if(!selectedStory || selectedStory.key!==story.key) return;
        $('#songArticle').textContent = story.summary || 'Unable to load the full article. You can still try generating a song.';
        updateStatus(err.message || 'Unable to load the full article.'); updateGenerateButton({disabled:false,text:'Generate Song'});
      }
    }

    function handleHeadlineSelection(story){
      if(!story || !story.key){ updateStatus('This headline is missing critical information.'); return }
      if(isGenerating && story.key!==currentHeadlineKey){ updateStatus('Please wait until the current track finishes generating.'); return }

      currentHeadlineKey=story.key;
      selectedHeadlineSource=(story.source||'Latest Headlines').trim();
      headlineViewMode='stories';
      selectedStory=story; latestArticleContent=''; latestSummary='';
      refreshHeadlineView();

      $('#songTitle').textContent = story.headline || 'Selected headline';
      $('#songMeta').textContent = story.source || 'Breaking news';
      $('#songArticle').textContent = story.summary || 'Fetching the full article…';
      $('#songLyrics').textContent = 'Lyrics will appear once a Suno track has been generated.';

      const tag=$('#songTag'); tag.textContent='Article'; tag.style.background='rgba(245,158,11,.18)'; tag.style.color='var(--accent)';

      setActiveTab('article');
      updateGenerateButton({disabled:true, text:'Loading Article…'});
      updateStatus('Fetching the full article…');
      fetchAndDisplayArticle(story);
      // if mobile, switch to the Now Playing tab
      if (window.innerWidth <= 860) {
        document.querySelectorAll('.mobile-bottom-nav__button').forEach(b => 
          b.classList.remove('active')
        );
        const nowPlayingBtn = document.querySelector(
          '.mobile-bottom-nav__button[data-section="player"]'
        );
        nowPlayingBtn?.classList.add('active');

        // toggle visible panels
        document.querySelectorAll('.sidebar-section, .player-panel').forEach(p => 
          p.classList.remove('active')
        );
        document.querySelector('.player-panel')?.classList.add('active');
      }
    }

    async function pollForAudioIds({taskIds=[], clipIds=[]}, {timeoutMs=180000, intervalMs=5000, requireFinalAudioHost=false}={}){
      const start=Date.now();
      while(Date.now()-start < timeoutMs){
        const qs = clipIds.length ? `clip_ids=${encodeURIComponent(clipIds.join(','))}` : `task_ids=${encodeURIComponent(taskIds.join(','))}`;
        try{
          const r=await fetch(`/api/song-status?${qs}`);
          if(!r.ok){ await new Promise(res=>setTimeout(res,intervalMs)); continue }
          const {data=[]}=await r.json(); const ready=data.find(d=>d && d.audio_url);
          if(ready){
            if(requireFinalAudioHost){
              const final=isFinalSunoState(ready.state);
              const migrating=(()=>{ try{ const h=new URL(ready.audio_url).hostname.toLowerCase(); return SUNO_AUDIO_HOST_MIGRATIONS.has(h) }catch{ return false }})();
              if(!final || migrating){ await new Promise(res=>setTimeout(res,intervalMs)); continue }
            }
            return ready;
          }
        }catch{ await new Promise(res=>setTimeout(res,intervalMs)) }
      }
      throw new Error('Timed out waiting for Suno audio.');
    }

    function populateFromSuno(song){
      const createdAt = song.createdAt instanceof Date ? song.createdAt : new Date();
      const pieces=[]; if(song.sunoTitle) pieces.push(`Suno: ${song.sunoTitle}`); if(song.articleSource) pieces.push(song.articleSource);
      if(song.tags) pieces.push(`Tags: ${song.tags}`);
      const ts=formatDateTime(createdAt); if(ts) pieces.push(ts);

      $('#songTitle').textContent = song.articleHeadline || song.sunoTitle || 'Daily Spin (Suno)';
      $('#songMeta').textContent = pieces.join(' — ') || 'Generated';

      const articleParts=[]; if(song.articleHeadline) articleParts.push(song.articleHeadline);
      if(song.articleContent) articleParts.push(song.articleContent); else if(song.articleSummary) articleParts.push(song.articleSummary);
      $('#songArticle').textContent = articleParts.join('\n\n') || 'Your Suno track is ready. Enjoy!';
      $('#songLyrics').textContent = (song.lyrics || song.prompt || '').trim() || 'Lyrics were not provided for this spin.';

      const src = getPlayableAudioUrl(song.audioUrl || song.streamUrl || '');
      $('#audioSource').src = src; $('#audioPlayer').load(); if(src){ $('#audioPlayer').play().catch(()=>{}) }

      const tag=$('#songTag'); tag.textContent='Now Playing'; tag.style.background='rgba(245,158,11,.18)'; tag.style.color='var(--accent)';
      currentSongId=null;
      updateDockState();
    }

    async function generateSongForHeadline(story){
      if(!story?.link){ updateStatus('The selected headline does not have a readable article link.'); return }
      if(isGenerating) return;

      isGenerating=true; latestSummary=''; updateGenerateButton({disabled:true, text:'Generating…'});
      $('#audioSource').src=''; $('#audioPlayer').load();

      const selectedTags = getRequestedTags();

      try{
        const payload={url:story.link,headline:story.headline,source:story.source};
        if(selectedTags) payload.tags = selectedTags;
        const r=await fetch('/api/generate-song',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
        const body=await r.json().catch(()=>({}));
        if(r.status!==202) throw new Error(body?.error || 'Failed to create a Suno generation task.');

        const appliedTags = typeof body?.tags==='string' && body.tags.trim() ? body.tags.trim() : selectedTags;

        latestSummary = body.summary || body.prompt || story.summary || '';

        $('#songArticle').textContent = latestSummary || 'Waiting for OpenRouter to provide a summary…';
        $('#songLyrics').textContent = 'Lyrics will appear once Suno finishes rendering your track.';
        setActiveTab('article');

        const taskIds = Array.isArray(body.task_ids) ? body.task_ids : [];
        const clipIds = Array.isArray(body.clip_ids) ? body.clip_ids : [];
        if(!taskIds.length && !clipIds.length) throw new Error('Suno did not return any task or clip identifiers.');
        const waitMessage = appliedTags ? `Song requested with tags: ${appliedTags}. Waiting for Suno to render…` : 'Song requested. Waiting for Suno to render…';
        updateStatus(waitMessage);

        const clip = await pollForAudioIds({taskIds, clipIds}, {timeoutMs:180000, intervalMs:15000});
        const createdAt = clip.created_at ? new Date(clip.created_at) : new Date();
        const streamUrl = sanitizeAudioUrl(clip.audio_url);
        const imageUrl = sanitizeImageUrl(clip.image_url || '');
        const summaryText = (latestSummary || body.prompt || '').trim();
        const normalizedTaskIds = Array.from(new Set([
          ...taskIds.map(v=>typeof v==='string'?v.trim():'').filter(Boolean),
          typeof clip.task_id==='string' ? clip.task_id.trim() : ''
        ].filter(Boolean)));

        const songRecord = {
          id: clip.id || null,
          audioUrl: streamUrl,
          streamUrl,
          title: clip.title || 'Daily Spin (Suno)',
          artist: clip.artist || 'Suno AI',
          sunoTitle: clip.title || 'Daily Spin (Suno)',
          sunoArtist: clip.artist || 'Suno AI',
          lyrics: (summaryText || clip.lyrics || '').trim(),
          prompt: summaryText,
          createdAt,
          generatedAtIso: createdAt.toISOString(),
          imageUrl,
          taskIds: normalizedTaskIds,
          primaryTaskId: normalizedTaskIds[0] || '',
          articleHeadline: story.headline || '',
          articleSummary: story.summary || '',
          articleSource: story.source || '',
          articleUrl: story.link || '',
          articleContent: latestArticleContent || '',
          tags: appliedTags,
        };

        populateFromSuno(songRecord);

        let saved=false; let docRef=null;
        try{ await initFirebase(); docRef = await saveGeneratedSong(songRecord); saved=true }catch(e){ console.warn('Save failed:', e) }

        if(docRef){
          finalizeSongAudio({docRef, taskIds, clipIds, streamUrl, songRecord})
            .catch(e=>console.warn('Finalize audio later failed:', e));
        }

        updateStatus(saved ? 'Your Suno song is ready and saved to Recent Spins.' : 'Your Suno song is ready, but it could not be saved to Recent Spins.');
        updateGenerateButton({disabled:false, text:'Generate Another Song'});
      }catch(err){
        updateStatus(err.message || 'Something went wrong while generating the song.');
        latestSummary='';
        updateGenerateButton({disabled:false, text: selectedStory && selectedStory.key===story.key ? 'Try Again' : 'Generate Song'});
      }finally{
        isGenerating=false; refreshHeadlineView();
      }
    }

    async function initFirebase(){
      if(firebaseInitPromise) return firebaseInitPromise;
      firebaseInitPromise = (async ()=>{
        const r=await fetch('/api/firebase-config'); if(!r.ok) throw new Error('Unable to load Firebase configuration.');
        const config=await r.json(); const app=initializeApp(config); db=getFirestore(app); return db;
      })();
      return firebaseInitPromise;
    }

    async function saveGeneratedSong(song){
      if(!db) throw new Error('Firebase is not available.');
      if(!song) throw new Error('Suno did not return an audio URL to save.');

      const sanitizedStreamUrl = sanitizeAudioUrl(song?.streamUrl || '');
      const sanitizedFinalUrl  = sanitizeAudioUrl(song?.audioUrl  || '');
      const persistedAudioUrl = sanitizedFinalUrl || sanitizedStreamUrl;
      if(!persistedAudioUrl) throw new Error('Suno did not return an audio URL to save.');

      const songsRef = collection(db,'spins');
      const generatedIso = song.generatedAtIso || (song.createdAt instanceof Date ? song.createdAt.toISOString() : new Date().toISOString());
      const sanitizedImageUrl = sanitizeImageUrl(song?.imageUrl || '');
      const normalizedTaskIds = Array.isArray(song?.taskIds) ? Array.from(new Set(song.taskIds.map(v=>typeof v==='string'?v.trim():'').filter(Boolean))) : [];
      const primaryTaskId = typeof song?.primaryTaskId==='string' ? song.primaryTaskId.trim() : normalizedTaskIds[0] || '';

      const payload = {
        kind: song.kind || 'song',
        sunoTitle: song.sunoTitle || song.title || 'Daily Spin (Suno)',
        sunoArtist: song.sunoArtist || song.artist || 'Suno AI',
        lyrics: (song.lyrics || '').trim(),
        audioUrl: persistedAudioUrl,
        streamUrl: sanitizedStreamUrl,
        imageUrl: sanitizedImageUrl,
        prompt: song.prompt || '',
        articleHeadline: song.articleHeadline || '',
        articleSummary: song.articleSummary || '',
        articleSource: song.articleSource || '',
        articleUrl: song.articleUrl || '',
        articleContent: song.articleContent || '',
        taskIds: normalizedTaskIds,
        primaryTaskId,
        createdAt: serverTimestamp(),
        generatedAtIso: generatedIso,
        tags: typeof song.tags==='string' ? song.tags.trim() : '',
      };
      return addDoc(songsRef, payload);
    }

    async function savePodcastEpisode(podcast){
      if(!db) throw new Error('Firebase is not available.');
      if(!podcast) throw new Error('No podcast payload to save.');

      const episodesRef = collection(db,'podcasts');
      const generatedIso = podcast.createdAtIso || new Date().toISOString();

      const segments = (podcast.selections || []).map(seg=>{
        const song = seg.song || {};
        return {
          headline: seg.headline || '',
          source: seg.source || '',
          summary: seg.summary || '',
          link: seg.link || '',
          deepDiveScript: seg.deepDiveScript || '',
          overviewScript: seg.overviewScript || '',
          articleContent: seg.articleContent || '',
          songPrompt: seg.songPrompt || '',
          songTaskIds: Array.isArray(seg.songTaskIds) ? seg.songTaskIds : [],
          songClipIds: Array.isArray(seg.songClipIds) ? seg.songClipIds : [],
          song: {
            audioUrl: sanitizeAudioUrl(song.audioUrl || ''),
            streamUrl: sanitizeAudioUrl(song.streamUrl || ''),
            imageUrl: sanitizeImageUrl(song.imageUrl || ''),
            taskIds: Array.isArray(seg.songTaskIds) ? seg.songTaskIds : [],
            clipIds: Array.isArray(seg.songClipIds) ? seg.songClipIds : [],
            tags: seg.tags || '',
          },
        };
      });

      const payload = {
        overviewScript: podcast.overviewScript || '',
        createdAt: serverTimestamp(),
        generatedAtIso: generatedIso,
        selections: segments,
      };

      return addDoc(episodesRef, payload);
    }

    function pickPrimaryPodcastSong(selections){
      if(!Array.isArray(selections)) return {};
      const withAudio = selections.find(seg=>{
        const song = seg.song || {};
        return sanitizeAudioUrl(song.audioUrl || song.streamUrl || '');
      });
      const candidate = withAudio || selections[0] || {};
      const song = candidate.song || {};

      const audioUrl = sanitizeAudioUrl(song.audioUrl || song.streamUrl || '');
      const streamUrl = sanitizeAudioUrl(song.streamUrl || '');
      const imageUrl = sanitizeImageUrl(song.imageUrl || '');
      const taskIds = Array.isArray(candidate.songTaskIds) ? candidate.songTaskIds : Array.isArray(song.taskIds) ? song.taskIds : [];
      const clipIds = Array.isArray(candidate.songClipIds) ? candidate.songClipIds : Array.isArray(song.clipIds) ? song.clipIds : [];

      return {
        audioUrl,
        streamUrl,
        imageUrl,
        taskIds,
        clipIds,
        headline: candidate.headline || '',
        source: candidate.source || '',
      };
    }

    async function savePodcastSpin({podcast, episodeRef}){
      if(!db) throw new Error('Firebase is not available.');
      if(!podcast) throw new Error('No podcast payload to save.');

      const spinsRef = collection(db,'spins');
      const generatedIso = podcast.createdAtIso || new Date().toISOString();
      const selections = Array.isArray(podcast.selections) ? podcast.selections : [];
      const firstSong = pickPrimaryPodcastSong(selections);
      const primaryTaskId = firstSong.taskIds?.[0] || '';
      const headlineForMeta = selections[0]?.headline || 'Daily Spin Podcast';

      const payload = {
        kind: 'podcast',
        sunoTitle: 'Daily Spin Podcast',
        sunoArtist: 'Daily Spin',
        lyrics: (podcast.overviewScript || '').trim(),
        audioUrl: firstSong.audioUrl || '',
        streamUrl: firstSong.streamUrl || '',
        imageUrl: firstSong.imageUrl || '',
        prompt: podcast.overviewScript || '',
        articleHeadline: headlineForMeta,
        articleSummary: podcast.overviewScript || '',
        articleSource: 'Podcast',
        articleUrl: '',
        articleContent: podcast.overviewScript || '',
        taskIds: Array.isArray(firstSong.taskIds) ? firstSong.taskIds : [],
        primaryTaskId,
        createdAt: serverTimestamp(),
        generatedAtIso: generatedIso,
        tags: '',
        podcastOverview: podcast.overviewScript || '',
        podcastSelections: selections,
        podcastId: episodeRef?.id || '',
      };

      return addDoc(spinsRef, payload);
    }

    async function finalizePodcastEpisode({docRef, selections=[]}){
      if(!docRef || !selections.length) return;

      const resolvedSelections = await Promise.all(selections.map(async (seg)=>{
        const taskIds = Array.isArray(seg.songTaskIds) ? seg.songTaskIds : [];
        const clipIds = Array.isArray(seg.songClipIds) ? seg.songClipIds : [];
        let finalAudio='', finalImage='';
        if(taskIds.length || clipIds.length){
          const finalClip = await pollForAudioIds({taskIds, clipIds},{timeoutMs:240000, intervalMs:12000, requireFinalAudioHost:true}).catch(()=>null);
          finalAudio = sanitizeAudioUrl(finalClip?.audio_url || '', {migrateHost:true});
          finalImage = sanitizeImageUrl(finalClip?.image_url || '');
        }
        return {
          ...seg,
          song: {
            audioUrl: finalAudio || seg.song?.audioUrl || seg.song?.streamUrl || '',
            streamUrl: seg.song?.streamUrl || '',
            imageUrl: finalImage || seg.song?.imageUrl || '',
            taskIds,
            clipIds,
            tags: seg.tags || '',
          },
        };
      }));

      await updateDoc(docRef, { selections: resolvedSelections });
      return resolvedSelections;
    }

    async function finalizePodcastSpin({docRef, selections=[]}){
      if(!docRef) return;
      const resolvedSelections = Array.isArray(selections) ? selections : [];
      const primary = pickPrimaryPodcastSong(resolvedSelections);

      const updatePayload = {
        podcastSelections: resolvedSelections,
      };

      if(primary.audioUrl || primary.streamUrl){
        updatePayload.audioUrl = primary.audioUrl || primary.streamUrl;
        updatePayload.streamUrl = primary.streamUrl || primary.audioUrl || '';
        updatePayload.imageUrl = primary.imageUrl || '';
        updatePayload.taskIds = Array.isArray(primary.taskIds) ? primary.taskIds : [];
        updatePayload.primaryTaskId = (primary.taskIds || [])[0] || '';
        updatePayload.articleHeadline = primary.headline || 'Daily Spin Podcast';
        updatePayload.articleSource = primary.source || 'Podcast';
      }

      await updateDoc(docRef, updatePayload);

      if(primary.taskIds?.length || primary.clipIds?.length){
        finalizeSongAudio({
          docRef,
          taskIds: primary.taskIds || [],
          clipIds: primary.clipIds || [],
          streamUrl: primary.streamUrl,
        }).catch(err=>console.warn('Finalize podcast spin audio failed:', err));
      }
    }

    async function finalizeSongAudio({docRef, taskIds=[], clipIds=[], streamUrl, songRecord}){
      if(!docRef || (!taskIds.length && !clipIds.length)) return;
      try{
        const finalClip = await pollForAudioIds({taskIds, clipIds},{timeoutMs:240000, intervalMs:10000, requireFinalAudioHost:true});
        const finalUrl = sanitizeAudioUrl(finalClip?.audio_url || '');
        const finalImageUrl = sanitizeImageUrl(finalClip?.image_url || '');
        if((!finalUrl || finalUrl===streamUrl) && !finalImageUrl) return;

        const updatePayload={};
        if(finalUrl && finalUrl!==streamUrl) updatePayload.audioUrl=finalUrl;
        if(finalImageUrl) updatePayload.imageUrl=finalImageUrl;
        if(Object.keys(updatePayload).length) await updateDoc(docRef, updatePayload);

        if(songRecord){
          if(finalUrl && finalUrl!==streamUrl) songRecord.audioUrl = finalUrl;
          if(finalImageUrl) songRecord.imageUrl = finalImageUrl;
        }
      }catch(err){
        // fallback: allow host migration if needed
        const fb = await pollForAudioIds({taskIds, clipIds},{timeoutMs:60000, intervalMs:10000}).catch(()=>null);
        if(!fb || !isFinalSunoState(fb.state)) throw err;
        const migratedUrl = sanitizeAudioUrl(fb.audio_url||'', {migrateHost:true});
        const migratedImg = sanitizeImageUrl(fb.image_url||'');
        if((!migratedUrl || migratedUrl===streamUrl) && !migratedImg) throw err;

        const updatePayload={};
        if(migratedUrl && migratedUrl!==streamUrl) updatePayload.audioUrl=migratedUrl;
        if(migratedImg) updatePayload.imageUrl=migratedImg;
        await updateDoc(docRef, updatePayload);

        if(songRecord){
          if(migratedUrl && migratedUrl!==streamUrl) songRecord.audioUrl=migratedUrl;
          if(migratedImg) songRecord.imageUrl=migratedImg;
        }
      }
    }

    function beginSongPollForSegment(seg){
      if(!seg || seg.songPromise) return seg?.songPromise;
      const taskIds = Array.isArray(seg.songTaskIds) ? seg.songTaskIds : [];
      const clipIds = Array.isArray(seg.songClipIds) ? seg.songClipIds : [];
      if(!taskIds.length && !clipIds.length){
        seg.songPromise = Promise.resolve(null);
        return seg.songPromise;
      }
      seg.songPromise = pollForAudioIds({taskIds, clipIds},{timeoutMs:240000, intervalMs:12000})
        .then(clip=>{
          const clipUrl = sanitizeAudioUrl(clip?.audio_url || '');
          const img = sanitizeImageUrl(clip?.image_url || '');
          seg.song = {
            audioUrl: clipUrl,
            streamUrl: clipUrl,
            imageUrl: img,
            taskIds,
            clipIds,
            tags: seg.tags || '',
          };
          return seg.song;
        })
        .catch(err=>{
          console.warn('Podcast segment audio failed:', err);
          return null;
        });
      return seg.songPromise;
    }

    function mapSpinDocument(doc){
      const d=doc.data();
      const createdAt = coerceDate(d.createdAt, d.generatedAtIso);

      const rawAudioUrl = sanitizeAudioUrl(d.audioUrl);
      const rawStreamUrl = sanitizeAudioUrl(d.streamUrl);
      const img = sanitizeImageUrl(d.imageUrl || d.image_url || '');
      const storedTaskIds = Array.isArray(d.taskIds) ? d.taskIds.map(v=>typeof v==='string'?v.trim():'').filter(Boolean) : [];
      const primaryTaskId = typeof d.primaryTaskId==='string' ? d.primaryTaskId.trim() : storedTaskIds[0] || '';

      return {
        id: doc.id,
        title: d.title || d.sunoTitle || 'Daily Spin (Suno)',
        sunoTitle: d.sunoTitle || d.title || 'Daily Spin (Suno)',
        artist: d.artist || d.sunoArtist || 'Suno AI',
        sunoArtist: d.sunoArtist || d.artist || 'Suno AI',
        kind: d.kind || 'song',
        lyrics: d.lyrics || d.prompt || d.podcastOverview || '',
        audioUrl: rawAudioUrl || rawStreamUrl,
        streamUrl: rawStreamUrl,
        imageUrl: img,
        createdAt,
        prompt: d.prompt || '',
        articleHeadline: d.articleHeadline || '',
        articleSummary: d.articleSummary || d.prompt || d.podcastOverview || '',
        articleSource: d.articleSource || '',
        articleUrl: d.articleUrl || '',
        articleContent: d.articleContent || d.podcastOverview || '',
        tags: typeof d.tags==='string' ? d.tags.trim() : '',
        taskIds: storedTaskIds,
        primaryTaskId,
        podcastOverview: d.podcastOverview || '',
        podcastSelections: Array.isArray(d.podcastSelections) ? d.podcastSelections : [],
        podcastId: d.podcastId || '',
      };
    }

    function mapPodcastDocument(doc){
      const d = doc.data();
      const createdAt = coerceDate(d.createdAt, d.generatedAtIso);
      const selections = Array.isArray(d.selections) ? d.selections : [];
      const primary = pickPrimaryPodcastSong(selections);

      const headline = primary.headline || selections[0]?.headline || 'Daily Spin Podcast';
      const source = selections[0]?.source || 'Podcast';
      const overview = d.overviewScript || '';

      return {
        id: doc.id,
        title: 'Daily Spin Podcast',
        sunoTitle: 'Daily Spin Podcast',
        artist: 'Daily Spin',
        sunoArtist: 'Daily Spin',
        kind: 'podcast',
        lyrics: overview,
        audioUrl: primary.audioUrl || primary.streamUrl || '',
        streamUrl: primary.streamUrl || '',
        imageUrl: primary.imageUrl || '',
        createdAt,
        prompt: overview,
        articleHeadline: headline,
        articleSummary: overview || '',
        articleSource: source,
        articleUrl: selections[0]?.link || '',
        articleContent: overview || '',
        tags: '',
        taskIds: Array.isArray(primary.taskIds) ? primary.taskIds : [],
        primaryTaskId: (primary.taskIds || [])[0] || '',
        podcastOverview: overview,
        podcastSelections: selections,
        podcastId: doc.id,
      };
    }

    function mergeRecentItems(){
      const seen = new Set();
      const merged = [];

      [...spinsCache, ...podcastsCache].forEach(item=>{
        if(!item) return;
        const key = `${item.kind || 'song'}:${item.podcastId || item.id || ''}`;
        if(seen.has(key)) return;
        if(item.kind==='podcast'){
          if(!(item.podcastOverview || (item.podcastSelections||[]).length)) return;
        } else if(!item.audioUrl){
          return;
        }
        seen.add(key);
        merged.push(item);
      });

      merged.sort((a,b)=>{
        const aTime = a?.createdAt instanceof Date ? a.createdAt.getTime() : 0;
        const bTime = b?.createdAt instanceof Date ? b.createdAt.getTime() : 0;
        return bTime - aTime;
      });

      return merged;
    }

    async function playPodcastQueue({persist=true}={}) {
      if(!podcastState) return;
      podcastIsRunning = true;
      podcastQueueIndex = -1;
      podcastNavRequest = null;

      const selections = Array.isArray(podcastState.selections) ? podcastState.selections : [];
      const steps = [];

      if(podcastState.overviewScript){
        steps.push({ type: 'overview', script: podcastState.overviewScript });
      }
      selections.forEach((seg, idx)=> steps.push({ type: 'segment', seg, index: idx }));

      if(selections[0]) beginSongPollForSegment(selections[0]);

      let stepIndex = Math.max(0, currentPodcastStep >=0 ? currentPodcastStep : 0);
      if(stepIndex >= steps.length) stepIndex = 0;

      updatePodcastStatus('Starting podcast narration…');
      renderPodcastScripts();
      updatePodcastControlButtons();

      while(stepIndex < steps.length){
        const step = steps[stepIndex];
        currentPodcastStep = stepIndex;
        updatePodcastControlButtons();

        if(step.type === 'overview'){
          updatePodcastStatus('Narrating podcast overview…');
          const res = await speakText(step.script);
          const nav = res?.nav || takePodcastNavRequest();
          if(nav === 'prev'){ stepIndex = Math.max(0, stepIndex - 1); continue; }
          if(nav === 'next'){ stepIndex = Math.min(steps.length, stepIndex + 1); continue; }
        }

        if(step.type === 'segment'){
          podcastQueueIndex = step.index;
          renderPodcastScripts();
          const seg = step.seg;
          updatePodcastStatus(`Talking through ${seg.headline || 'a top story'}…`);
          const res = await speakText(seg.deepDiveScript || seg.overviewScript || seg.reason || '');
          const nav = res?.nav || takePodcastNavRequest();
          if(nav === 'prev'){ stepIndex = Math.max(0, stepIndex - 1); continue; }
          if(nav === 'next'){ stepIndex = Math.min(steps.length, stepIndex + 1); continue; }

          const song = await beginSongPollForSegment(seg);
          if(podcastNavRequest){
            const dir = takePodcastNavRequest();
            stepIndex = dir === 'prev' ? Math.max(0, stepIndex - 1) : Math.min(steps.length, stepIndex + 1);
            continue;
          }

          if(song && (song.audioUrl || song.streamUrl)){
            updatePodcastStatus('Playing Suno track…');
            await playClip(song.audioUrl || song.streamUrl);
          }

          const pendingNav = takePodcastNavRequest();
          if(pendingNav === 'prev'){ stepIndex = Math.max(0, stepIndex - 1); continue; }
          if(pendingNav === 'next'){ stepIndex = Math.min(steps.length, stepIndex + 1); continue; }

          const next = selections[step.index+1];
          if(next) beginSongPollForSegment(next);
        }

        stepIndex += 1;
      }

      podcastQueueIndex = -1;
      currentPodcastStep = -1;
      podcastNavRequest = null;
      renderPodcastScripts();
      updatePodcastStatus('Podcast finished.');
      updatePodcastControlButtons();

      if(persist && podcastState){
        try{
          await initFirebase();

          // Reuse pre-saved refs if present, otherwise create them
          let episodeRef = podcastState.episodeRef;
          let spinRef = podcastState.spinRef;

          if(!episodeRef){
            episodeRef = await savePodcastEpisode(podcastState);
            podcastState.episodeRef = episodeRef;
          }

          if(!spinRef){
            spinRef = await savePodcastSpin({ podcast: podcastState, episodeRef });
            podcastState.spinRef = spinRef;
          }

          finalizePodcastEpisode({ docRef: episodeRef, selections: podcastState.selections })
            .then(resolved => finalizePodcastSpin({
              docRef: spinRef,
              selections: resolved || podcastState.selections
            }))
            .catch(e => console.warn('Finalize podcast episode failed:', e));
        }catch(err){
          console.warn('Failed to save podcast episode:', err);
        }
      }

      podcastIsRunning = false;
      updatePodcastControlButtons();
    }


    async function subscribeToSongs(){
      if(!db) return;
      if(unsubscribeSongs) unsubscribeSongs();
      if(unsubscribePodcasts) unsubscribePodcasts();

      const songsRef=collection(db,'spins');
      const songsQuery=query(songsRef, orderBy('createdAt','desc'), limit(50));
      const podcastsRef = collection(db,'podcasts');
      const podcastsQuery = query(podcastsRef, orderBy('createdAt','desc'), limit(50));

      const refreshList = (opts={})=>{
        const merged = mergeRecentItems();

        if(!merged.length){
          currentSongId=null; songsCache=[];
          showListEmptyState('songList', opts.errorMessage || 'No spins or podcasts have been generated yet. Be the first to spin one!');
          resetNowPlaying();
          return;
        }

        songsCache = merged;
        renderSongList(merged);

        const selected = currentSongId ? merged.find(s=>s.id===currentSongId) : null;

        // When a podcast is mid-generation/playback, avoid auto-switching to a new
        // item (which could hijack the player and clear the podcast scripts).
        if(selected){
          setCurrentSong(selected);
        } else if(!podcastIsRunning && merged[0]){
          setCurrentSong(merged[0]);
        }
      };

      unsubscribeSongs = onSnapshot(songsQuery, (snap)=>{
        spinsCache = snap.docs
          .map(mapSpinDocument)
          .filter(s=>Boolean(s.audioUrl));
        refreshList();
      }, (err)=>{
        console.error('Firebase load error:',err);
        refreshList({errorMessage:'Unable to load recent spins right now.'});
      });

      unsubscribePodcasts = onSnapshot(podcastsQuery, (snap)=>{
        podcastsCache = snap.docs.map(mapPodcastDocument);
        refreshList();
      }, (err)=>{
        console.error('Firebase podcast load error:',err);
        refreshList({errorMessage:'Unable to load recent spins right now.'});
      });
    }

    function renderSongList(songs){
      songsCache=songs;
      const list=$('#songList'), tpl=$('#songItemTemplate');
      if(!songs.length){ showListEmptyState('songList','No Suno songs have been generated yet. Be the first to spin one!'); return }
      list.innerHTML='';
      songs.forEach(song=>{
        const node=tpl.content.cloneNode(true);
        const btn=node.querySelector('button');
        const title=node.querySelector('.song-title');
        const meta=node.querySelector('.song-meta');
        const thumb=node.querySelector('.song-thumb');
        const img=thumb.querySelector('img');
        const ph=thumb.querySelector('.song-thumb-placeholder');

        const displayTitle = song.kind==='podcast'
          ? (song.articleHeadline || 'Daily Spin Podcast')
          : (song.articleHeadline || song.sunoTitle || song.title || 'Daily Spin (Suno)');
        title.textContent = displayTitle;

        const metaPieces=[];
        if(song.kind==='podcast') metaPieces.push('Podcast');
        if(song.sunoTitle || song.title) metaPieces.push(`Suno: ${song.sunoTitle || song.title}`);
        if(song.articleSource) metaPieces.push(song.articleSource);
        if(song.tags) metaPieces.push(`Tags: ${song.tags}`);
        const ts=formatDateTime(song.createdAt); if(ts) metaPieces.push(ts);
        meta.textContent = metaPieces.filter(Boolean).join(' • ');

        const thumbUrl=sanitizeImageUrl(song.imageUrl || song.image_url || '');
        ph.textContent = (displayTitle || 'AI').trim().slice(0,2).toUpperCase() || 'AI';
        if(thumbUrl){ img.src=thumbUrl; thumb.classList.add('has-image') } else { img.removeAttribute('src'); thumb.classList.remove('has-image') }

        btn.dataset.id=song.id || '';
        btn.classList.toggle('active', !!(song.id && song.id===currentSongId));
        btn.addEventListener('click', ()=> setCurrentSong(song));

        list.appendChild(node);
      });
    }

    async function resolveSongAudioUrl(song){
      if(!song) return '';

      if(song._resolvedFinalAudioUrl && !hasAudioPipeHost(song._resolvedFinalAudioUrl)){
        return song._resolvedFinalAudioUrl;
      }

      const raw = sanitizeAudioUrl(song.audioUrl || song.streamUrl || '');
      if(!raw) return '';

      if(!hasAudioPipeHost(raw)){
        song._resolvedFinalAudioUrl = raw;
        return raw;
      }

      if(song._resolvingAudioPromise){
        try{ return await song._resolvingAudioPromise }catch{ return raw }
      }

      const normalizedTaskIds = (()=>{
        const ids=[];
        const primary = typeof song.primaryTaskId==='string' ? song.primaryTaskId.trim() : '';
        if(primary) ids.push(primary);
        if(Array.isArray(song.taskIds)){
          for(const id of song.taskIds){
            if(typeof id==='string'){
              const trimmed=id.trim();
              if(trimmed) ids.push(trimmed);
            }
          }
        }
        return Array.from(new Set(ids.filter(Boolean)));
      })();

      if(!normalizedTaskIds.length){
        song._resolvedFinalAudioUrl = raw;
        return raw;
      }

      const resolver = (async ()=>{
        try{
          const qs = encodeURIComponent(normalizedTaskIds.join(','));
          const r = await fetch(`/api/song-status?task_ids=${qs}`);
          if(!r.ok) throw new Error('Unable to fetch updated Suno audio.');
          const payload = await r.json().catch(()=>({}));
          const rows = Array.isArray(payload?.data) ? payload.data : [];

          const preferred = rows.find(row=>row && row.audio_url && !hasAudioPipeHost(row.audio_url));
          const fallback = rows.find(row=>row && row.audio_url);
          const resolved = sanitizeAudioUrl((preferred || fallback || {}).audio_url || '', {migrateHost:true});

          if(resolved){
            song.audioUrl = resolved;
            song._resolvedFinalAudioUrl = resolved;
            const idx = songsCache.findIndex(s=>s && s.id===song.id);
            if(idx>=0){
              songsCache[idx].audioUrl = resolved;
              songsCache[idx]._resolvedFinalAudioUrl = resolved;
            }
            return resolved;
          }
        }catch(err){
          console.warn('Failed to resolve Suno audio URL:', err);
        }
        return raw;
      })();

      song._resolvingAudioPromise = resolver;
      try{
        return await resolver;
      }finally{
        delete song._resolvingAudioPromise;
      }
    }

    function setCurrentSong(song){
      if(!song){ resetNowPlaying(); podcastState=null; renderPodcastScripts(); return }
      currentSongId = song.id || null;

      const isPodcast = song.kind === 'podcast';
      const displayTitle = isPodcast
        ? (song.articleHeadline || 'Daily Spin Podcast')
        : (song.articleHeadline || song.sunoTitle || song.title || 'Daily Spin (Suno)');
      $('#songTitle').textContent = displayTitle;

      const metaPieces=[];
      if(isPodcast) metaPieces.push('Podcast');
      if(song.sunoTitle || song.title) metaPieces.push(`Suno: ${song.sunoTitle || song.title}`);
      if(song.articleSource) metaPieces.push(song.articleSource);
      if(song.tags) metaPieces.push(`Tags: ${song.tags}`);
      const ts=formatDateTime(song.createdAt); if(ts) metaPieces.push(ts);
      $('#songMeta').textContent = metaPieces.join(' — ') || 'Generated';

      const articleParts=[];
      if(song.articleHeadline) articleParts.push(song.articleHeadline);
      if(isPodcast){
        if(song.podcastOverview) articleParts.push(song.podcastOverview);
        const segmentScripts = (song.podcastSelections||[])
          .map(seg=>`— ${seg.headline || 'Story'}\n${seg.deepDiveScript || seg.overviewScript || seg.reason || ''}`)
          .filter(Boolean)
          .join('\n\n');
        if(segmentScripts) articleParts.push(segmentScripts);
      }else if(song.articleContent){
        articleParts.push(song.articleContent);
      } else if(song.articleSummary){
        articleParts.push(song.articleSummary);
      }

      $('#songArticle').textContent = articleParts.join('\n\n') || 'Article details are unavailable for this spin.';
      $('#songLyrics').textContent = (song.lyrics || song.prompt || song.podcastOverview || '').trim() || 'Lyrics were not provided for this spin.';

      if(isPodcast){
        podcastState = {
          overviewScript: song.podcastOverview || song.articleContent || '',
          selections: Array.isArray(song.podcastSelections) ? song.podcastSelections : [],
          createdAtIso: song.generatedAtIso || (song.createdAt instanceof Date ? song.createdAt.toISOString() : new Date().toISOString()),
        };
        currentPodcastStep = 0;
        renderPodcastScripts();
        updatePodcastControlButtons();
        if(!podcastIsRunning){
          updatePodcastStatus('Playing saved podcast episode…');
          playPodcastQueue({persist:false}).catch(err=>{
            console.warn('Podcast playback from archive failed:', err);
            updatePodcastStatus(err?.message || 'Unable to play podcast episode.');
          });
        }
      } else {
        podcastState = null;
        currentPodcastStep = -1;
        renderPodcastScripts();
        updatePodcastControlButtons();

        const rawAudio = sanitizeAudioUrl(song.audioUrl || song.streamUrl || '');
        const playable=getPlayableAudioUrl(rawAudio);
        const currentSrc = $('#audioSource').getAttribute('src') || '';
        if(playable !== currentSrc){
          $('#audioSource').src = playable; $('#audioPlayer').load();
          if(playable) $('#audioPlayer').play().catch(()=>{});
        }else if(playable){ $('#audioPlayer').play().catch(()=>{}) }

        if(hasAudioPipeHost(rawAudio)){
          resolveSongAudioUrl(song).then(finalRaw=>{
            if(!finalRaw || hasAudioPipeHost(finalRaw)) return;
            if((song.id || null)!==currentSongId) return;
            const finalPlayable = getPlayableAudioUrl(finalRaw);
            const current = $('#audioSource').getAttribute('src') || '';
            if(finalPlayable && finalPlayable!==current){
              $('#audioSource').src = finalPlayable;
              $('#audioPlayer').load();
              $('#audioPlayer').play().catch(()=>{});
            }
          }).catch(err=>console.warn('Audio migration failed:', err));
        }
      }

      const tag=$('#songTag');
      const isNewest = songsCache[0]?.id === song.id;
      if(isNewest){ tag.textContent='Now Playing'; tag.style.background='rgba(245,158,11,.18)'; tag.style.color='var(--accent)' }
      else{ tag.textContent='From the Archives'; tag.style.background='rgba(148,163,184,.2)'; tag.style.color='var(--text)' }

      $$('[data-role="song-item"]').forEach(b=> b.classList.toggle('active', b.dataset.id===(song.id||'')));

      if(window.innerWidth <= 860){
        setActiveMobileSection('player');
      }

      updateDockState();
    }

    async function generatePodcastEpisode({ persist = true } = {}) {
      if (podcastIsRunning) {
        updatePodcastStatus('A podcast is already running.');
        return;
      }
      if (!headlinesCache.length) {
        updatePodcastStatus('Load headlines first, then try again.');
        return;
      }

      podcastIsRunning = true;
      podcastQueueIndex = -1;
      updatePodcastStatus('Asking OpenRouter for a podcast script…');
      renderPodcastScripts();
      updatePodcastControlButtons();

      try {
        const payload = { stories: headlinesCache };
        // 🔹 FAST PLAN PHASE: get overview & host scripts asap
        const r = await fetch('/api/generate-podcast?phase=plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const body = await r.json().catch(() => ({}));
        if (!r.ok) throw new Error(body?.error || 'Unable to start podcast.');

        const selections = Array.isArray(body?.selections) ? body.selections : [];
        podcastState = {
          overviewScript: body.overviewScript || '',
          selections,
          createdAtIso: body.createdAtIso || new Date().toISOString(),
        };
        currentPodcastStep = 0;

        // 🔹 Pre-save to Firebase as you already do
        let episodeRef = null;
        let spinRef = null;
        if (persist) {
          try {
            await initFirebase();
            episodeRef = await savePodcastEpisode(podcastState);
            spinRef = await savePodcastSpin({ podcast: podcastState, episodeRef });

            podcastState.episodeRef = episodeRef;
            podcastState.spinRef = spinRef;
          } catch (err) {
            console.warn('Failed to pre-save podcast episode:', err);
          }
        }

        renderPodcastScripts();
        updatePodcastControlButtons();
        updatePodcastStatus('Narrating podcast and generating Suno songs…');

        // 🔹 Kick off full generation in the background (deep dives + Suno)
        (async () => {
          try {
            const rFull = await fetch('/api/generate-podcast', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            const fullBody = await rFull.json().catch(() => ({}));
            if (!rFull.ok) throw new Error(fullBody?.error || 'Unable to finish podcast generation.');

            const fullSelections = Array.isArray(fullBody?.selections)
              ? fullBody.selections
              : [];

            // Replace selections in-place so playPodcastQueue sees richer data
            if (podcastState) {
              podcastState.selections = fullSelections;
              renderPodcastScripts();
            }
          } catch (err) {
            console.warn('Background podcast enrichment failed:', err);
          }
        })();

        // 🔹 Start playback immediately using overviewScript + host scripts
        playPodcastQueue({ persist }).catch((err) => {
          console.warn('Podcast playback failed:', err);
          updatePodcastStatus(err?.message || 'Podcast playback failed.');
          podcastIsRunning = false;
          updatePodcastControlButtons();
        });
      } catch (err) {
        updatePodcastStatus(err.message || 'Unable to generate podcast.');
        podcastIsRunning = false;
        updatePodcastControlButtons();
      }
    }



    /* ---------- Boot ---------- */
    document.addEventListener('DOMContentLoaded', async ()=>{
      genreSelect = $('#genreSelect');
      customTagsInput = $('#customTagsInput');
      generateSongButton = $('#generateSongButton');
      generatePodcastButton = $('#generatePodcastButton');
      podcastPrevButton = $('#podcastPrevButton');
      podcastNextButton = $('#podcastNextButton');
      podcastPlayPauseButton = $('#podcastPlayPauseButton');
      customTagsInput?.addEventListener('keydown', evt=>{
        if(evt.key==='Enter'){
          evt.preventDefault();
          generateSongButton?.click();
        }
      });
      generateSongButton?.addEventListener('click', ()=>{
        if(!selectedStory){ updateStatus('Select a headline to read the story before generating a song.'); return }
        generateSongForHeadline(selectedStory);
      });
      generatePodcastButton?.addEventListener('click', ()=>{
        generatePodcastEpisode();
      });

      podcastPrevButton?.addEventListener('click', ()=> requestPodcastNavigation('prev'));
      podcastNextButton?.addEventListener('click', ()=> requestPodcastNavigation('next'));
      podcastPlayPauseButton?.addEventListener('click', togglePodcastPause);

      // Desktop sidebar tabs
      document.querySelectorAll('[data-role="desktop-sidebar-tab"]').forEach(btn => {
        btn.addEventListener('click', () => setActiveDesktopSidebar(btn.dataset.target));
      });

      // Initialize default desktop view to "headlines"
      setActiveDesktopSidebar('headlines');

      // Keep desktop tabs only affecting desktop; when switching to mobile, your mobile code takes over
      const desktopMQ = window.matchMedia('(min-width: 861px)');
      desktopMQ.addEventListener?.('change', e => {
        if (e.matches) {
          // entering desktop — ensure a single section is active
          setActiveDesktopSidebar(
            document.querySelector('[data-role="desktop-sidebar-tab"].active')?.dataset.target || 'headlines'
          );
        } else {
          // entering mobile — show the mobile view’s default (your code already handles this)
          // No action required here.
        }
      });


      $$('[data-role="player-tab"]').forEach(btn=>{
        btn.addEventListener('click', ()=> setActiveTab(btn.dataset.tab));
      });
      setActiveTab(activeContentTab);

      const navButtons = document.querySelectorAll('[data-role="mobile-nav"]');
      navButtons.forEach(btn=>{
        btn.addEventListener('click', ()=> setActiveMobileSection(btn.dataset.target));
      });
      setActiveMobileSection('headlines');

      const audio=$('#audioPlayer');

      const mq=window.matchMedia('(max-width: 860px)');

      showListEmptyState('songList','Loading recent spins…');
      resetNowPlaying();
      updateDockState();
      updatePodcastControlButtons();

      // Headlines
      (async ()=>{
        const list=$('#headlineList'); if(list) list.innerHTML='<li class="empty-state">Loading headlines…</li>';
        try{
          const r=await fetch('/api/news-headlines'); const payload=await r.json().catch(()=>({}));
          if(!r.ok) throw new Error(payload?.error || 'Unable to fetch the latest headlines.');
          const stories = Array.isArray(payload?.stories) ? payload.stories : [];
          if(!stories.length){ showListEmptyState('headlineList','No headlines are available right now. Please check back soon.'); updateStatus('Headlines are unavailable right now.'); return }
          setHeadlines(stories);
        }catch(err){
          showListEmptyState('headlineList','We could not load the latest headlines. Please try again later.');
          updateStatus(err.message || 'Unable to load headlines right now.');
          resetNowPlaying();
        }
      })();

      // Firebase
      try{ await initFirebase(); await subscribeToSongs() }
      catch(e){ console.error('Firebase init error:', e); showListEmptyState('songList','Unable to load recent spins right now.') }
    });

    const dock = document.getElementById('dockedAudio');
    const appShell = document.querySelector('.app-shell');
    const mqDesktop = window.matchMedia('(min-width: 861px)');

    function placeDock(e){
      const wantDesktop = e ? e.matches : mqDesktop.matches;
      if (wantDesktop) {
        // ensure it's inside the grid, after the player panel
        if (dock.parentElement !== appShell) {
          appShell.appendChild(dock);  // now grid-column:2 applies
        }
      } else {
        // ensure it's a direct child of body (outside blur/backdrop stack)
        if (dock.parentElement !== document.body) {
          document.body.appendChild(dock);
        }
      }
    }

    // initial placement + on changes
    placeDock();
    mqDesktop.addEventListener ? mqDesktop.addEventListener('change', placeDock)
                              : mqDesktop.addListener(placeDock);

  </script>
</body>
</html>